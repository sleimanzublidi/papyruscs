<!DOCTYPE html>
<html>
<head>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
          crossorigin="anonymous" />

    <link href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css"
          rel="stylesheet">

    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
          rel="stylesheet" />

    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css"
          integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc="
          crossorigin="anonymous" />

    <style>
        html,
        body,
        #map {
            margin: 0px;
            border: 0px;
            padding: 0px;
            width: 100%;
            height: 97.5%;
        }

        .layer-select {
            position: absolute;
            top: 0.5em;
            right: 0.5em;
            width: 150px;
        }

        .ol-mouse-position {
            background-color: #ffffff;
            border: 1px solid gray;
            border-radius: 5px;
            padding: 0.25em 0.5em;
        }

        #map {
            background: #202020;
            font-size: 16px;
            font-family: "Roboto", sans-serif;
        }

        /* note: attempt at fixing blurry zoom */
        #map, img, canvas {
            image-rendering: -moz-crisp-edges; /* Firefox */
            image-rendering: -o-crisp-edges; /* Opera */
            image-rendering: -webkit-optimize-contrast; /* Webkit (non-standard naming) */
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */
        }

        .ol-popup {
            position: absolute;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            padding: 18px;
            border-radius: 10px;
            border: 1px solid #cccccc;
            bottom: 12px;
            left: -50px;
            min-width: 148px;
        }

            .ol-popup:after, .ol-popup:before {
                top: 100%;
                border: solid transparent;
                content: " ";
                height: 0;
                width: 0;
                position: absolute;
                pointer-events: none;
            }

            .ol-popup:after {
                border-top-color: white;
                border-width: 10px;
                left: 48px;
                margin-left: -10px;
            }

            .ol-popup:before {
                border-top-color: #cccccc;
                border-width: 11px;
                left: 48px;
                margin-left: -11px;
            }

        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 2px;
            right: 8px;
        }

            .ol-popup-closer:after {
                content: "✖";
            }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>

<body margin="0" padding="0">
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
            integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
            integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
            crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
            integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
            crossorigin="anonymous"></script>

    <script src="playersData.js"></script>
    <script src="poiData.js"></script>
    <script src="portalData.js"></script>
    <script src="villageData.js"></script>

    <div id="map" class="map"></div>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
            <div id="locationElement" class="navbar-nav mr-auto mt-2 mt-lg-0 text-light">
            </div>
            <form class="form-inline my-2 my-lg-0" onsubmit="return preventSubmit();">
                <button id="gotoBtn" class="btn btn-outline-light my-2 mr-sm-2" type="submit">Go to</button>
                <input id="gotoX" class="form-control mr-sm-2" placeholder="X">
                <input id="gotoZ" class="form-control mr-sm-2" placeholder="Z">
            </form>
        </div>
    </nav>

    <div id="popup" class="ol-popup">
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>

    <script>
        function preventSubmit() { return false; }

        var layers = {
            dim0: {
                name: "Overworld",
                attribution: '',
                minNativeZoom: 10,
                maxNativeZoom: 20,
                noWrap: true,
                tileSize: 256,
                folder: "dim0",
                fileExtension: "png"
            }
        };
        var config = { "factor": 65536.0, "globalMinZoom": 10, "globalMaxZoom": 20, "tileSize": 256, "blocksPerTile": 16 };

        // layers = {"dim0":{"name":"Overworld","attribution":"","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim0","fileExtension":"png"},"dim0_underground":{"name":"Underground","attribution":"","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim0_underground","fileExtension":"png"},"dim0_ore":{"name":"Ores","attribution":"","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim0_ore","fileExtension":"png"},"dim0_stronghold":{"name":"Strongholds","attribution":"","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim0_stronghold","fileExtension":"png"},"dim0_aquatic":{"name":"Aquatic","attribution":"","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim0_aquatic","fileExtension":"png"},"dim1":{"name":"Nether","attribution":"","minNativeZoom":13,"maxNativeZoom":20,"noWrap":true,"tileSize":256,"folder":"dim1","fileExtension":"png"}};

        // The values above will be injected and replaced.
        // # INJECT DATA HERE

        // ======

        // For the extent sizes specified below, OpenLayers tries to fit
        // the whole extents given in a space [0, 0] -> [2^8, 2^8] visually
        // on screen at zoom level 0.
        //
        // This constant represents that internal tile size that OpenLayers
        // will aim for, so that we can calculate zoom levels correctly later.
        const openLayersInternalTileSize = Math.pow(2, 8); // 256

        // The actual size of the tiles that we're using in Papyrus.
        const tileSize = config.tileSize;

        // The maximum positive extents of the whole map. The units for this
        // value are "number of tiles at the most zoomed out level generated
        // by Papyrus". That is, if Papyrus generates a minimum zoom level
        // of 15, then the units for this extent size are the number of (Papyrus)
        // zoom level 15 tiles to display at (OpenLayers) zoom level 0.
        //
        // The minimum zoom level that Papyrus is using is in config.globalMinZoom.
        const maximumExtentSize = 10000;

        // The minimum negative extents of the whole map. Uses the same units
        // as maximumExtentSize.
        const minimumExtentSize = -10000;

        // Computes the resolutions array to use for OpenLayers. For each OpenLayers
        // zoom level (0 through 42), this computes the ratio such that a single tile
        // at OpenLayers zoom level 0 is a single tile at the minimum Papyrus zoom level.
        const papyrusMinimumZoomScale = Math.pow(2, config.globalMinZoom);
        const convertedFromTilesToPixelsUsingTileSize = papyrusMinimumZoomScale / tileSize;
        const resolutions = new Array(43);
        for (let z = 0; z < 43; ++z) {
            resolutions[z] = convertedFromTilesToPixelsUsingTileSize / Math.pow(2, z);
        }

        // When we calculate resolutions above, we've effectively saying that zoom level 0 is
        // zoom level N, where N is the lowest zoom level. This zoom level N also becomes
        // the range of [0, 0] -> [1, 1] in the coordinate system. We need to be able to translate
        // coordinates in that "zoomed out" coordinate system, back down to the maximum zoom level
        // where each tile represents 32x32 (depending on tilesize) Minecraft tiles.
        const zoomRatioForMaximumZoom = 1 / Math.pow(2, config.globalMaxZoom - config.globalMinZoom);
        const minecraftTilesAtMostZoomedInLevel = config.blocksPerTile;

        const centerX = 1536;
        const centerZ = 0;

        // Use a projection where pixels have a 1:1 ratio with the screen at zoom level 0.
        const projection = new ol.proj.Projection({
            code: "ZOOMIFY",
            units: "pixels",
            extent: [
                0,
                0,
                openLayersInternalTileSize / tileSize,
                openLayersInternalTileSize / tileSize
            ],
            metersPerUnit: 16,
            // getPointResolution: function(resolution, coordinate) {
            //     return resolution;
            // }
        });

        function toBlockCoordidate(c) {
            return Math.floor((c / zoomRatioForMaximumZoom) * minecraftTilesAtMostZoomedInLevel);
        }

        function toMapCoordidate(c) {
            return (c * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel;
        }

        // Construct the tile grid using the desired maximum and minimum extents listed above,
        // set the origin to [0, 0] (the center of the map), and the calculated resolutions array.
        const tileGrid = new ol.tilegrid.TileGrid({
            extent: [
                minimumExtentSize,
                minimumExtentSize,
                maximumExtentSize,
                maximumExtentSize
            ],
            origin: [0, 0],
            resolutions: resolutions,
            tileSize: [tileSize, tileSize]
        });

        // * Html Elements *

        let map;
        let locationElement = document.getElementById("locationElement");
        let gotoBtn = document.getElementById("gotoBtn");
        let gotoX = document.getElementById("gotoX");
        let gotoZ = document.getElementById("gotoZ");

        gotoX.value = centerX;
        gotoZ.value = centerZ;

        // * Tile Layers *

        const tileLayers = Object.keys(layers)
            .sort()
            .map(function(layerKey, idx) {
                const layer = layers[layerKey];
                const tileLayer = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        tileUrlFunction: function(tileCoord, pixelRatio, projection) {
                            const z = tileCoord[0];
                            const x = tileCoord[1];
                            const y = tileCoord[2];
                            return ("./" + layer.folder + "/" + z + "/" + x + "/" + y + "." + layer.fileExtension);
                        },
                        projection: projection,
                        tileGrid: tileGrid,
                        attributions: layer.attribution
                    }),
                    visible: idx == 0
                });
                tileLayer.metaLayerKey = layerKey;
                return tileLayer;
            });

        let currentSelectedLayerKey = Object.keys(layers).sort()[0];
        const initialLayer = layers[currentSelectedLayerKey];

        let rememberedCenters = {};
        let rememberedZoom = {};

        function onSelectedLayerChanged(layerKey) {
            if (layerKey == "dim0_stronghold") {
                document.getElementById("map").style.background = "#fff";
            } else {
                document.getElementById("map").style.background = "#202020";
            }

            if (currentSelectedLayerKey != layerKey) {
                const runtimeLayers = map.getLayers();
                let layer = layers[layerKey];

                runtimeLayers.forEach(function(runtimeLayer) {
                    var visible = runtimeLayer.metaLayerKey == layerKey ||
                        runtimeLayer.metaLayerKey == layerKey.substr(0, 4) + "_players" ||
                        runtimeLayer.metaLayerKey == layerKey.substr(0, 4) + "_poi"
                    runtimeLayer.setVisible(visible);
                });

                const oldFocusGroup = currentSelectedLayerKey.substr(0, 4);
                const newFocusGroup = layerKey.substr(0, 4);

                rememberedCenters[oldFocusGroup] = view.getCenter();
                if (rememberedCenters[newFocusGroup] === undefined) {
                    // refocus the map to 0, 0
                    view.setCenter([0, 0]);

                    gotoX.value = toBlockCoordidate(0);
                    gotoZ.value = toBlockCoordidate(0);
                } else {
                    // set back to where we were
                    var center = rememberedCenters[newFocusGroup];
                    view.setCenter(center);

                    gotoX.value = toBlockCoordidate(center[0]);
                    gotoZ.value = toBlockCoordidate(center[1]);
                }

                rememberedZoom[oldFocusGroup] = view.getZoom();
                view.setMinZoom(layer.minNativeZoom - config.globalMinZoom);
                view.setMaxZoom(layer.maxNativeZoom - config.globalMinZoom);
                if (rememberedZoom[newFocusGroup] === undefined) {
                    // rezoom the map to minimum zoom
                    view.setZoom(layer.minNativeZoom - config.globalMinZoom);
                } else {
                    // set back to where we were
                    view.setZoom(rememberedZoom[newFocusGroup]);
                }

                const radios = $("input[name='layers']");
                radios.each(function(idx, elem) {
                    if (elem.value == layerKey) {
                        elem.checked = true;
                    } else {
                        elem.checked = false;
                    }
                });

                currentSelectedLayerKey = layerKey;
            }
        }

        // * View *

        const view = new ol.View({
            projection: projection,
            center: [toMapCoordidate(centerX), toMapCoordidate(centerZ)],
            zoom: config.globalMaxZoom,
            minZoom: 0,
            maxZoom: config.globalMaxZoom - config.globalMinZoom
        });

        // * Controls *

        gotoBtn.addEventListener(
            "click",
            function x(e) {
                var x = toMapCoordidate(gotoX.value);
                var z = -1 * toMapCoordidate(gotoZ.value);
                view.setCenter([x, z]);
                //view.setZoom(10);
            },
            false
        );

        const PapyrusControls = (function(Control) {
            function PapyrusControls(opt_options) {
                const options = opt_options || {};

                const element = document.createElement("div");
                element.className = "layer-select ol-unselectable";

                const card = document.createElement("div");
                card.className = "card";
                element.appendChild(card);

                const cardBody = document.createElement("div");
                cardBody.className = "card-body p-3 px-3";
                card.appendChild(cardBody);

                const form = document.createElement("form");
                cardBody.appendChild(form);

                Object.keys(layers)
                    .sort()
                    .forEach(function(layerKey, idx) {
                        const layer = layers[layerKey];

                        const radioContainer = document.createElement("div");
                        radioContainer.className = "custom-control custom-radio";

                        const radioInput = document.createElement("input");
                        radioInput.type = "radio";
                        radioInput.id = layerKey;
                        radioInput.name = "layers";
                        radioInput.className = "custom-control-input";
                        radioInput.checked = idx == 0;
                        radioInput.value = layerKey;
                        radioContainer.appendChild(radioInput);

                        const radioLabel = document.createElement("label");
                        radioLabel.htmlFor = layerKey;
                        radioLabel.className = "custom-control-label";
                        radioLabel.innerText = layer.name;
                        radioContainer.appendChild(radioLabel);

                        const selectLayer = function(e) { onSelectedLayerChanged(layerKey); };
                        radioInput.addEventListener(
                            "click",
                            selectLayer.bind(this),
                            false
                        );

                        form.appendChild(radioContainer);
                    });

                const hr = document.createElement("hr");
                form.appendChild(hr);

                Control.call(this, {
                    element: element,
                    target: options.target
                });
            }

            if (Control) PapyrusControls.__proto__ = Control;
            PapyrusControls.prototype = Object.create(Control && Control.prototype);
            PapyrusControls.prototype.constructor = PapyrusControls;

            return PapyrusControls;
        })(ol.control.Control);

        // * Overlay Popup *
        var popup = document.getElementById('popup');
        var popupContent = document.getElementById('popup-content');
        var popupCloser = document.getElementById('popup-closer');

        var popupOverlay = new ol.Overlay({
            element: popup,
            autoPan: true,
            autoPanAnimation: {
                duration: 250,
            },
        });

        popupCloser.onclick = function() {
            popupOverlay.setPosition(undefined);
            popupCloser.blur();
            return false;
        };

        // * Map *

        map = new ol.Map({
            target: "map",
            layers: tileLayers,
            overlays: [popupOverlay],
            view: view,
            controls: [
                new ol.control.Zoom(),
                new ol.control.ScaleLine(),
                new PapyrusControls()
            ]
        });

        map.on("pointermove", function(event) {
            var x = toBlockCoordidate(event.coordinate[0]);
            var z = toBlockCoordidate(-event.coordinate[1]);
            var cX = Math.floor(x / 16);
            var cZ = Math.floor(z / 16);

            locationElement.innerHTML = `<div><h5>${x}, ${z}</h5></div><div class="ml-2"><small>(${cX}, ${cZ})</small></div>`;
        });

        map.on("singleclick", function(event) {
            var zoom = map.getView().getZoom();
            var coordinate = event.coordinate;

            var x = toBlockCoordidate(event.coordinate[0]);
            var z = toBlockCoordidate(-event.coordinate[1]);
            var cX = Math.floor(x / 16);
            var cZ = Math.floor(z / 16);

            popupContent.innerHTML = `${x}, ${z} <br/><small>${cX}, ${cZ}</small>`;
            popupOverlay.setPosition(coordinate);
        });

        // * Players *
        var payersLayer = null;

        function createPayersLayer() {
            if (payersLayer != null)
                return;

            if (typeof (playersData) !== "undefined") {
                var playerFeatures = [[], [], []];

                for (var playerIndex in playersData.players) {
                    var player = playersData.players[playerIndex];

                    if (!player.visible) {
                        continue;
                    }

                    var style = new ol.style.Style({
                        text: new ol.style.Text({
                            text: "\uf183",
                            font: "900 18px 'Font Awesome 5 Free'",
                            textBaseline: "bottom",
                            fill: new ol.style.Fill({ color: player.color }),
                            stroke: new ol.style.Stroke({ color: "white", width: 2 })
                        })
                    });

                    var playerFeature = new ol.Feature({
                        geometry: new ol.geom.Point([toMapCoordidate(player.position[0]), toMapCoordidate(-player.position[2])])
                    });

                    playerFeature.setStyle(style);

                    playerFeatures[player.dimensionId].push(playerFeature);
                }

                for (var dimensionId = 0; dimensionId < 3; dimensionId++) {
                    var vectorSource = new ol.source.Vector({ features: playerFeatures[dimensionId] });
                    var vectorLayer = new ol.layer.Vector({ source: vectorSource });
                    vectorLayer.metaLayerKey = "dim" + dimensionId + "_players";

                    var visible = vectorLayer.metaLayerKey == currentSelectedLayerKey.substr(0, 4) + "_players"
                    vectorLayer.setVisible(visible);

                    map.addLayer(vectorLayer);
                }

                payersLayer = vectorLayer;
            }
        }

        // * Points of Interest *
        var poiLayer = null;

        function createPOILayer() {
            if (poiLayer != null)
                return;

            var poiList = [];

            if (typeof (poiData) !== "undefined") {
                poiList = poiList.concat(poiData.points);
            }

            if (typeof (villageData) !== "undefined") {
                poiList = poiList.concat(villageData.villages);
            }

            if (typeof (portalData) !== "undefined") {
                poiList = poiList.concat(portalData.portals);
            }

            if (poiList.length > 0) {
                var poiFeatures = [[], [], []];

                for (var poiIndex in poiList) {
                    var poi = poiList[poiIndex];

                    if (!poi.visible) {
                        continue;
                    }

                    var style = new ol.style.Style({
                        text: new ol.style.Text({
                            text: poi.icon + "\n" + poi.name,
                            font: "900 18px 'Font Awesome 5 Free'",
                            textBaseline: "bottom",
                            fill: new ol.style.Fill({ color: poi.color }),
                            stroke: new ol.style.Stroke({ color: "white", width: 2 })
                        })
                    });

                    var poiFeature = new ol.Feature({
                        geometry: new ol.geom.Point([toMapCoordidate(poi.position[0]), toMapCoordidate(-poi.position[2])])
                    });

                    poiFeature.setStyle(style);
                    poiFeatures[poi.dimensionId].push(poiFeature);
                }

                for (var dimensionId = 0; dimensionId < 3; dimensionId++) {
                    var vectorSource = new ol.source.Vector({ features: poiFeatures[dimensionId] });
                    var vectorLayer = new ol.layer.Vector({ source: vectorSource });
                    vectorLayer.metaLayerKey = "dim" + dimensionId + "_poi";

                    var visible = vectorLayer.metaLayerKey == currentSelectedLayerKey.substr(0, 4) + "_poi"
                    vectorLayer.setVisible(visible);

                    map.addLayer(vectorLayer);
                }

                poiLayer = vectorLayer;
            }
        }

        onSelectedLayerChanged(currentSelectedLayerKey);
        createPayersLayer();
        createPOILayer();

    </script>
</body>
</html>
